<!DOCTYPE html>
<html lang="fr">
    <style>
        /* Reset et base */
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            min-height: 100vh;
        }

        /* En-t√™te */
        h1 {
            text-align: center;
            margin: 10px 0;
            font-size: 1.5rem;
        }

        /* R√©organisation pour une structure en trois blocs */
        .header {
            width: 100%;
            text-align: center;
            padding: 20px 0;
            background-color: #f4f4f4;
            font-size: 1.5rem;
            font-weight: bold;
        }

        .button-container {
            width: 100%;
            text-align: center;
            padding: 20px 0;
            background-color: #ffffff;
        }

        /* Conteneur principal */
        .map-list-container {
            display: flex;
            width: 100%;
            height: 80vh;
        }

        /* Nouveau conteneur pour la carte et le bouton */
        .map-container {
            display: flex;
            flex-direction: column; /* Aligner le bouton et la carte verticalement */
            flex: 2; /* La carte et son bouton occupent 2/3 de l'espace */
            background-color: #eaeaea;
            padding: 10px;
        }

        /* Bouton pour afficher/masquer la carte (mobile) */
        .map-toggle {
            display: block; /* Toujours visible */
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px;
            margin: 10px auto; /* Centrer le bouton sous le titre */
            width: auto; /* Ajuster la largeur pour qu'elle s'adapte au contenu */
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
        }

        /* Carte */
        #map {
            height: 80vh; /* Ajuster la hauteur pour qu'elle soit plus grande */
            margin-top: 10px; /* Espacement entre le bouton et la carte */
            width: 100%;
            border: 1px solid #ccc;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
            display: none; 
        }

        /* Liste des joueurs */
        .list-container {
            flex: 1;
            background-color: #ffffff;
            padding: 10px;
            overflow-y: auto;
        }

        /* Classement */
        #classement {
            flex: 1; /* La liste des joueurs occupe 1/3 de l'espace */
            max-height: 80vh; /* Limiter la hauteur pour √©viter le d√©bordement */
            overflow-y: auto; /* Ajouter un d√©filement si n√©cessaire */
            width: 100%;
            background-color: white;
            border-radius: 4px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            padding: 0;
            box-sizing: border-box;
        }

        /* Tableau */
        table {
            width: 100%;
            border-collapse: collapse;
            background-color: white;
            font-size: 0.9rem;
        }

        th, td {
            padding: 8px 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        th {
            position: sticky;
            top: 0;
            background-color: #4CAF50;
            color: white;
            z-index: 1;
        }

        /* Lignes du tableau */
        tr:nth-child(even) {
            background-color: #f2f2f2;
        }

        tr:hover {
            background-color: #ddd;
        }

        /* Cellules sp√©cifiques */
        .points-cell {
            position: relative;
            cursor: help;
        }

        .tooltip {
            display: none;
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            padding: 8px;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
            white-space: nowrap;
            right: 0;
            font-size: 0.8rem;
        }

        .points-cell:hover .tooltip {
            display: block;
        }

        .clickable {
            cursor: pointer;
            text-decoration: underline;
            color: rgb(0, 0, 0);
        }

        .best-score.clickable {
            color: #4CAF50; /* Vert pour les best-score */
        }
        .qualified {
            background-color: #90EE90 !important;
        }

        .qualified:hover {
            background-color: #78c278 !important;
        }

        /* R√©gions */
        .region-color {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 5px;
            border-radius: 2px;
        }

        .Marron-color { background-color: #311415; }
        .Vert-color { background-color: #32832E }
        .Jaune-color { background-color: #D8AE04 }
        .Violet-color { background-color: #5D2F71 }
        .Cyan-color { background-color: #45B6CC }
        .Orange-color { background-color: #E95C02 }
        .Rouge-color { background-color: #dd0000; }
        .Vert-Clair-color { background-color: #15DD6A; }

        /* Responsive : Mobile */
        /* Bouton pour afficher/masquer la carte */
        .map-toggle {
            display: block; /* Toujours visible */
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px;
            margin: 10px auto;
            width: 80%;
            max-width: 300px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
        }

        /* Carte visible par d√©faut sur PC, masqu√©e sur mobile */
        #map {
            height: 50vh;
            width: 100%;
            border: 1px solid #ccc;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
            margin-bottom: 10px;
              display: none; 
        }

        /* Ajustement pour organiser la disposition avec le titre, le bouton, et la carte/liste */
        .container {
            display: flex;
            flex-direction: row; /* Aligner la carte et la liste horizontalement */
            justify-content: space-between;
            align-items: flex-start;
            margin-top: 20px; /* Espacement entre le bouton et le contenu */
        }

        .map-container {
            display: flex;
            flex-direction: column; /* Aligner le bouton et la carte verticalement */
            flex: 2; /* La carte et son bouton occupent 2/3 de l'espace */
        }

        #map {
            height: 80vh; /* Ajuster la hauteur pour qu'elle soit plus grande */
            margin-top: 10px; /* Espacement entre le bouton et la carte */
        }

        #classement {
            flex: 1; /* La liste des joueurs occupe 1/3 de l'espace */
            max-height: 80vh; /* Limiter la hauteur pour √©viter le d√©bordement */
            overflow-y: auto; /* Ajouter un d√©filement si n√©cessaire */
        }

        .map-toggle {
            display: block; /* Toujours visible */
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px;
            margin: 10px auto; /* Centrer le bouton sous le titre */
            width: auto; /* Ajuster la largeur pour qu'elle s'adapte au contenu */
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
        }

        /* Ajout de styles pour les t√©l√©phones (responsive design) */
        @media (max-width: 768px) {
            .container {
                flex-direction: column; /* Revenir √† une disposition verticale */
                align-items: center; /* Centrer les √©l√©ments */
            }

            .map-container {
                width: 100%; /* La carte prend toute la largeur */
            }

            #map {
                height: 50vh; /* R√©duire la hauteur de la carte */
                margin: 0; /* Supprimer les marges inutiles */
            }

            #classement {
                width: 100%; /* La liste des joueurs prend toute la largeur */
                max-height: none; /* Supprimer la limite de hauteur */
                overflow-y: visible; /* D√©sactiver le d√©filement */
            }

            .map-toggle {
                margin: 10px auto; /* Centrer le bouton */
            }

            /* Ajout de styles pour l'affichage mobile */
            .map-list-container {
                flex-direction: column; /* Passer √† une disposition verticale */
            }

            .map-container, .list-container {
                flex: none; /* R√©initialiser la flexibilit√© */
                width: 100%; /* Prendre toute la largeur */
                height: auto; /* Ajuster la hauteur automatiquement */
            }
        }

    </style>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carte avec adresse de tournoi</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

</head>
<body>
    <div class="header">
        Master King of War France 2026
    </div>
    <div class="button-container">
        <button class="map-toggle" onclick="toggleMap()">Afficher/Masquer la carte</button>
    </div>
    <div class="map-list-container">
        <div class="map-container">
            <div id="map"></div>
        </div>
        <div id="classement" class="list-container">
            <table id="tableauJoueurs">
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Nom du joueur</th>
                        <th>R√©gion</th>
                        <th>Evenements</th>
                        <th>Points totaux</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
            </div>
          
        </div>
        
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
    const PLACE_DISPONIBLE = 15; // Nombre de places disponibles pour la qualification
    const MaxTournamentCount = 4;   // Constante pour le nombre maximum de tournois √† prendre en compte

        function toggleMap() {
    const mapElement = document.getElementById('map');
    const button = document.querySelector('.map-toggle');
    if (mapElement.style.display === 'none' || mapElement.style.display === '') {
        mapElement.style.display = 'block';
        button.textContent = 'Masquer la carte';
        // Redimensionner la carte Leaflet apr√®s affichage
        setTimeout(() => map.invalidateSize(), 100);
    } else {
        mapElement.style.display = 'none';
        button.textContent = 'Afficher la carte';
    }
}
toggleMap()
        // Initialisation de la carte

        const map = L.map('map').setView([46.603354, 1.888334], 6);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        // Ajout de l'image en superposition transparente sur la carte
        // D√©finir les coordonn√©es g√©ographiques des coins de l'image (bounds)
        // [Sud-Ouest, Nord-Est] : [[latSW, lonSW], [latNE, lonNE]]
        // Ces valeurs sont √† ajuster pour correspondre √† la France m√©tropolitaine
        var imageUrl = 'mapFrance.png';
        // Ajustement pr√©cis des bounds pour mapFrance.png
        // Sud-Ouest (latitude, longitude) et Nord-Est (latitude, longitude)
        // Ces valeurs sont affin√©es pour coller au contour de la France
        var imageBounds = [[41.25, -5.0], [51.3, 9.0]];
        // Pour agrandir l'image, on √©tend un peu les bounds (Sud plus bas, Nord plus haut, Ouest plus √† gauche, Est plus √† droite)
        var enlargedBounds = [[40.8, -6.0], [51.7, 10.0]];
        L.imageOverlay(imageUrl, enlargedBounds, {opacity: 0.45, interactive: false}).addTo(map);

/*
 function getDeptColor(code) {
        // Liste des codes
        const Marron = ["75", "77", "78", "91", "92", "93", "94", "95","14", "27", "50", "61", "76","22", "29", "35", "56","44", "49", "53", "72", "85"];
        const Vert = ['59', '62', '80','60','02'];
        const Jaune = ["18", "28", "36", "37", "41", "45",'23','87','19','03','63','15'];
        const Violet = ['08','51','10','52','89','59','21','71','58']
        const Cyan = ['55', '54', '57','67','88','68','70','25','39','90'];
        const Orange = ["16", "17", "23", "24", "33", "40", "47", "64", "79", "86", "87"];
        const Rouge = ["09", "11", "12", "30", "31", "32", "34", "46", "48", "65", "66", "81", "82"];
        const VertClair = ["04", "05", "06", "13", "83", "84","01", "07", "15", "26", "38", "42", "43", "63", "69", "73", "74","2B","2A"];

        // V√©rifier si le code est dans la liste
        if (Marron.includes(code)) {
            return "#311415"; 
        }else if (Vert.includes(code)) {
            return "#32832E";
        }else if (Jaune.includes(code)) {
            return "#D8AE04";
        }else if (Violet.includes(code)) {
            return "#5D2F71";
        }else if (Cyan.includes(code)) {
            return "#45B6CC";
        }else if (Orange.includes(code)) {
            return "#E95C02";
        }else if (Rouge.includes(code)) {
            return "#dd0000";
        }else if (VertClair.includes(code)) {
            return "#15DD6A";
        }
        

        return "#32832E"; // Couleur par d√©faut
    }
    function styleDept(feature) {
        const code = feature.properties.code || feature.properties.code_dep;

        return {
            color: "#555",
            weight: 0,
            fillColor: getDeptColor(code),
            fillOpacity: 0.6
        };
    }

  L.geoJSON(departementsGeoJSON, {
        style: styleDept,
       
    }).addTo(map);*/


        // Fonction de calcul des points
        function calculPoint(deuxJours, classement, nombreTotal) {
            // Calcul de base : (nombreTotal/2 arrondi inf√©rieur) - classement - 1
            let points = Math.floor(nombreTotal / 2) - (classement - 1);
            
            // Bonus pour les tournois sur deux jours
            if (deuxJours) {
                if (classement === 1) {
                    points += 6;
                } else if (classement === 2) {
                    points += 3;
                } else if (classement === 3) {
                    points += 1;
                }
            }
            
            // Retourne 0 si le r√©sultat est n√©gatif
            return Math.max(0, points);
        }


        // Cr√©ation de la classe Classement
        class Classement {
            constructor(nomTournoi, urlTournoi, classement, points) {
                this.nomTournoi = nomTournoi;
                this.urlTournoi = urlTournoi;
                this.classement = classement;
                this.points = points;
            }
        }

        // Cr√©ation de la classe Joueur
        class Joueur {
            constructor(nom, region, DateNaissance) {
                this.nom = nom;
                this.region = region;
                this.DateNaissance = DateNaissance;
                this.listeClassements = [];
                this.pointTotal = 0;
            }

            ajouterClassement(classement) {
                this.listeClassements.push(classement);
                // Trier les classements par points d√©croissants
                this.listeClassements.sort((a, b) => b.points - a.points);
                // Recalculer le total avec les MaxTournamentCount meilleurs r√©sultats
                this.pointTotal = this.listeClassements
                    .slice(0, MaxTournamentCount)
                    .reduce((sum, c) => sum + c.points, 0);
            }
        }


        // Champion de l'ann√©e derni√®re
        const ChampionLastYear = "Arthur aka \"AVL\"";

        // Liste globale des joueurs
        let allPlayers = new Map();

        // Charger d'abord les tournois
        const tournoiScript = document.createElement('script');
        tournoiScript.src = 'mockTournois.js';
        
        tournoiScript.onload = function() {
            if (typeof tournois !== 'undefined') {
                // Charger ensuite les joueurs
                const playersScript = document.createElement('script');
                playersScript.src = 'mockPlayer.js';
                document.body.appendChild(playersScript);

                playersScript.onload = function() {
                // Calculer les points pour chaque r√©sultat de chaque tournoi
                tournois.forEach(tournoi => {

                    const nombreTotal = tournoi.resultats.length;
                    tournoi.resultats.forEach(resultat => {
                        resultat.nombreDePoints = calculPoint(tournoi.deuxJours, resultat.classement, nombreTotal);
                    });
                    
                    // Calculer pointMax (points du premier)
                    tournoi.pointMax = tournoi.resultats.length > 0 ? tournoi.resultats[0].nombreDePoints : 0;
                    
                    // Calculer pointTotale (somme des points de tous les joueurs)
                    tournoi.pointTotale = tournoi.resultats.reduce((sum, resultat) => sum + resultat.nombreDePoints, 0);
                });

                // Grouper les tournois par coordonn√©es arrondies √† 3 d√©cimales
                const tournoiParCoords = tournois.reduce((acc, tournoi) => {
                    // Arrondir les coordonn√©es √† 3 d√©cimales
                    const latRound = Math.round(tournoi.lat * 1000) / 1000;
                    const lonRound = Math.round(tournoi.lon * 1000) / 1000;
                    const key = `${latRound},${lonRound}`;
                    
                    if (!acc[key]) {
                        acc[key] = {
                            lat: tournoi.lat, // Garder la premi√®re coordonn√©e exacte
                            lon: tournoi.lon,
                            tournois: []
                        };
                    }
                    acc[key].tournois.push(tournoi);
                    
                    // Si on vient d'ajouter un deuxi√®me tournoi ou plus √† ce groupe
                    if (acc[key].tournois.length > 1) {
                     //   console.log('Tournois regroup√©s aux coordonn√©es', latRound, lonRound, ':');
                        acc[key].tournois.forEach(t => console.log('-', t.nom));
                    }else{
                      //  console.log('Tournois tout seule', latRound, lonRound, ':');
                    }
                    return acc;
                }, {});

                // Cr√©er les markers pour chaque groupe de tournois
                Object.values(tournoiParCoords).forEach((group) => {
                    // Cr√©er le contenu du popup avec tous les tournois
                    const popupContent = group.tournois
                    .map(tournoi => {
                        const dateFin = tournoi.deuxJours ? ` au ${formatDateFR(new Date(new Date(tournoi.date).getTime() + 86400000).toISOString().split('T')[0])}` : '';
                        let popupContent = `
                            <b>${tournoi.nom}</b><br>
                            Date : ${formatDateFR(tournoi.date)}${dateFin}<br>
                            Points max : ${tournoi.pointMax}<br>
                            Points totaux : ${tournoi.pointTotale}<br>
                        `;
                        if (tournoi.url) {
                            popupContent += `<a href='${tournoi.url}' target='_blank'>Lien du tournoi</a>`;
                        }
                        return popupContent;
                    })
                    .join('<br><br>');
                    
                    L.marker([group.lat, group.lon]).addTo(map)
                        .bindPopup(popupContent);
                });

                // Cr√©ation des objets Joueur et de leurs classements
                if (typeof mockPlayer !== 'undefined') {
                    console.log('mockPlayer est d√©fini avec', mockPlayer.length, 'joueurs.');
                    // Initialiser les joueurs
                    mockPlayer.forEach(joueur => {
                        allPlayers.set(joueur.nom, new Joueur(joueur.nom, joueur.region,joueur.DateNaissance));
                    });

                

                    // Parcourir tous les tournois pour ajouter les classements
                    tournois.forEach(tournoi => {
                        tournoi.resultats.forEach(resultat => {
                            let joueur = allPlayers.get(resultat.nom);
                            if (joueur) {
                                const classement = new Classement(
                                    tournoi.nom,
                                    tournoi.url,
                                    resultat.classement,
                                    resultat.nombreDePoints
                                );
                                joueur.ajouterClassement(classement);
                            }
                        });
                    });

                    // Afficher le tableau des joueurs
                    const tbody = document.querySelector('#tableauJoueurs tbody');
                    const sortedPlayers = Array.from(allPlayers.values())
                        .sort((a, b) => {
                            // D'abord comparer les points totaux
                            const pointsDiff = b.pointTotal - a.pointTotal;
                            if (pointsDiff !== 0) return pointsDiff;

                            // En cas d'√©galit√©, comparer le nombre de tournois jou√©s
                            const tournoisDiff = a.listeClassements.length - b.listeClassements.length;
                            if (tournoisDiff !== 0) return tournoisDiff;

                            // En cas d'√©galit√©, comparer l'√¢ge (le plus jeune en premier)
                            // DateNaissance peut √™tre string ou number, on convertit en date
                            const dateA = new Date(a.DateNaissance).getTime();
                            const dateB = new Date(b.DateNaissance).getTime();
                            // Plus la date est grande, plus le joueur est jeune
                            return dateB - dateA;
                        });

                    // Placer le ChampionLastYear en t√™te de la liste tri√©e
                    sortedPlayers.sort((a, b) => {
    if (a.nom === ChampionLastYear) return -1; // ChampionLastYear en premier
    if (b.nom === ChampionLastYear) return 1;

    // Comparer les points totaux
    const pointsDiff = b.pointTotal - a.pointTotal;
    if (pointsDiff !== 0) return pointsDiff;

    // En cas d'√©galit√©, comparer le nombre de tournois jou√©s
    return a.listeClassements.length - b.listeClassements.length;
});

                    // Filtrer les joueurs pour n'afficher que ceux ayant particip√© √† au moins un tournoi ou √©tant le ChampionLastYear
                    const filteredPlayers = sortedPlayers.filter(joueur => 
    joueur.listeClassements.length > 0 || joueur.nom === ChampionLastYear
);

                    // Garder une trace des joueurs qualifi√©s
                    const qualifiedPlayers = new Set();
                    
                    // Qualifier le champion de l'ann√©e derni√®re
                    const championIndex = filteredPlayers.findIndex(j => j.nom === ChampionLastYear);
                    if (championIndex !== -1) {
                        qualifiedPlayers.add(filteredPlayers[championIndex].nom);
                    }

                    // Qualifier les 14 premiers non d√©j√† qualifi√©s
                    let qualifiedCount = 0;
                    filteredPlayers.forEach((joueur, index) => {
                        if (qualifiedCount < PLACE_DISPONIBLE && !qualifiedPlayers.has(joueur.nom)) {
                            qualifiedPlayers.add(joueur.nom);
                            qualifiedCount++;
                        }
                    });

                    // Qualifier les premiers de chaque r√©gion non d√©j√† qualifi√©s
                    const regions = new Set(filteredPlayers.map(j => j.region));
                    regions.forEach(region => {
                        if (region) { // Ignorer les r√©gions non sp√©cifi√©es
                            const firstInRegion = filteredPlayers.find(j => 
                                j.region === region && !qualifiedPlayers.has(j.nom)
                            );
                            if (firstInRegion) {
                                qualifiedPlayers.add(firstInRegion.nom);
                            }
                        }
                    });

                    // Afficher les joueurs filtr√©s
                    filteredPlayers.forEach(joueur => {
    const tr = document.createElement('tr');
    if (qualifiedPlayers.has(joueur.nom)) {
        tr.classList.add('qualified');
    }

    // Cr√©er le contenu du tooltip
    const tooltipContent = joueur.listeClassements
        .map((c, index) => {
            const isBest = index < MaxTournamentCount;
            return `<div class="${isBest ? 'best-score' : ''} clickable" onclick="window.open('${c.urlTournoi}', '_blank')">
${isBest ? '‚ñ∫ ' : '  '}${c.nomTournoi}: ${c.classement}e (${c.points} pts)
</div>`;
        })
        .join('');

    const position = filteredPlayers.indexOf(joueur) + 1;
    tr.innerHTML = `
        <td>${position}</td>
        <td>${joueur.nom} ${joueur.nom === ChampionLastYear ? 'üëë' : ''}</td>
        <td>
            <span class="region-color
                ${joueur.region === 'Marron' ? 'Marron-color' :
                  joueur.region === 'Vert' ? 'Vert-color' :
                  joueur.region === 'Jaune' ? 'Jaune-color' :
                  joueur.region === 'Violet' ? 'Violet-color' :
                  joueur.region === 'Cyan' ? 'Cyan-color' :
                  joueur.region === 'Orange' ? 'Orange-color' :
                  joueur.region === 'Rouge' ? 'Rouge-color' :
                  joueur.region === 'Vert Clair' ? 'Vert-Clair-color' : ''}"></span>
            ${joueur.region || 'Non sp√©cifi√©e'}
        </td>
        <td>${joueur.listeClassements.length}</td>
        <td class="points-cell">
            ${joueur.pointTotal}
            <div class="tooltip">${tooltipContent}</div>
        </td>
    `;
    // Ins√©rer une ligne de s√©paration en gras apr√®s la 15√®me ligne (apr√®s le 15√®me joueur)
    if (position === (PLACE_DISPONIBLE+2)) {
        const separator = document.createElement('tr');
        separator.innerHTML = `<td colspan="5" style="font-weight:bold; text-align:center; background:#222; color:#fff;"></td>`;
        tbody.appendChild(separator);
    }
    tbody.appendChild(tr);
});
                } else {
                    console.error('mockPlayer est ind√©fini.');
                }
                };
            }
        };
        document.body.appendChild(tournoiScript);
    </script>
    <script>
// Ajout d'une fonction pour formater les dates en fran√ßais
function formatDateFR(dateString) {
    const options = { day: 'numeric', month: 'long', year: 'numeric' };
    const date = new Date(dateString);
    return date.toLocaleDateString('fr-FR', options);
}



    </script>
    <!-- Ajout de la logique pour masquer la carte et √©tendre la liste -->
<script>
    document.addEventListener("DOMContentLoaded", function() {
        const toggleButton = document.querySelector(".map-toggle");
        const mapContainer = document.querySelector(".map-container");
        const listContainer = document.querySelector(".list-container");

        toggleButton.addEventListener("click", function() {
            if (mapContainer.style.display === "none") {
                mapContainer.style.display = "block";
                listContainer.style.flex = "1"; // Revenir √† 1/3 de largeur
                toggleButton.textContent = "Masquer la carte";
            } else {
                mapContainer.style.display = "none";
                listContainer.style.flex = "1 0 100%"; // Prendre toute la largeur
                toggleButton.textContent = "Afficher la carte";
            }
        });
    });
</script>
</body>
</html>
