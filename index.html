<!DOCTYPE html>
<html lang="fr">
       <style>
/* Reset et base */
body {
    margin: 0;
    padding: 0;
    font-family: Arial, sans-serif;
    background-color: #f0f0f0;
    min-height: 100vh;
}

/* En-t√™te */
h1 {
    text-align: center;
    margin: 10px 0;
    font-size: 1.5rem;
}

/* R√©organisation pour une structure en trois blocs */
.header {
    width: 100%;
    text-align: center;
    padding: 20px 0;
    background-color: #f4f4f4;
    font-size: 1.5rem;
    font-weight: bold;
}

.button-container {
    width: 100%;
    text-align: center;
    padding: 20px 0;
    background-color: #ffffff;
}

/* Conteneur principal */
.map-list-container {
    display: flex;
    width: 100%;
    height: 80vh;
}

/* Nouveau conteneur pour la carte et le bouton */
.map-container {
    display: flex;
    flex-direction: column; /* Aligner le bouton et la carte verticalement */
    flex: 2; /* La carte et son bouton occupent 2/3 de l'espace */
    background-color: #eaeaea;
    padding: 10px;
}

/* Bouton pour afficher/masquer la carte (mobile) */
.map-toggle {
    display: block; /* Toujours visible */
    background-color: #4CAF50;
    color: white;
    border: none;
    padding: 10px;
    margin: 10px auto; /* Centrer le bouton sous le titre */
    width: auto; /* Ajuster la largeur pour qu'elle s'adapte au contenu */
    border-radius: 4px;
    cursor: pointer;
    font-size: 1rem;
}

/* Carte */
#map {
    height: 80vh; /* Ajuster la hauteur pour qu'elle soit plus grande */
    margin-top: 10px; /* Espacement entre le bouton et la carte */
    width: 100%;
    border: 1px solid #ccc;
    box-shadow: 0 0 10px rgba(0,0,0,0.2);
    display: none; 
}

/* Liste des joueurs */
.list-container {
    flex: 1;
    background-color: #ffffff;
    padding: 10px;
    overflow-y: auto;
}

/* Classement */
#classement {
    flex: 1; /* La liste des joueurs occupe 1/3 de l'espace */
    max-height: 80vh; /* Limiter la hauteur pour √©viter le d√©bordement */
    overflow-y: auto; /* Ajouter un d√©filement si n√©cessaire */
    width: 100%;
    background-color: white;
    border-radius: 4px;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
    padding: 0;
    box-sizing: border-box;
}

/* Tableau */
table {
    width: 100%;
    border-collapse: collapse;
    background-color: white;
    font-size: 0.9rem;
}

th, td {
    padding: 8px 12px;
    text-align: left;
    border-bottom: 1px solid #ddd;
}

th {
    position: sticky;
    top: 0;
    background-color: #4CAF50;
    color: white;
    z-index: 1;
}

/* Lignes du tableau */
tr:nth-child(even) {
    background-color: #f2f2f2;
}

tr:hover {
    background-color: #ddd;
}

/* Cellules sp√©cifiques */
.points-cell {
    position: relative;
    cursor: help;
}

.tooltip {
    display: none;
    position: absolute;
    background: white;
    border: 1px solid #ccc;
    padding: 8px;
    border-radius: 4px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    z-index: 1000;
    white-space: nowrap;
    right: 0;
    font-size: 0.8rem;
}

.points-cell:hover .tooltip {
    display: block;
}

.clickable {
    cursor: pointer;
    text-decoration: underline;
    color: rgb(0, 0, 0);
}

.best-score.clickable {
    color: #4CAF50; /* Vert pour les best-score */
}
.qualified {
    background-color: #90EE90 !important;
}

.qualified:hover {
    background-color: #78c278 !important;
}

/* R√©gions */
.region-color {
    display: inline-block;
    width: 12px;
    height: 12px;
    margin-right: 5px;
    border-radius: 2px;
}

.bretagne-normandie-color { background-color: #80939c; }
.nord-color { background-color: #1fc03a; }
.loire-color { background-color: #48433f; }
.ardenne-bourgogne-color { background-color: #b46e39; }
.est-color { background-color: #9c7e81; }
.aquitaine-color { background-color: #ced0c4; }
.occitanie-color { background-color: #dd0000; }
.auvergne-color { background-color: #f5bf4c; }
.alpes-color { background-color: #9d9c6c; }

/* Responsive : Mobile */
/* Bouton pour afficher/masquer la carte */
.map-toggle {
    display: block; /* Toujours visible */
    background-color: #4CAF50;
    color: white;
    border: none;
    padding: 10px;
    margin: 10px auto;
    width: 80%;
    max-width: 300px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 1rem;
}

/* Carte visible par d√©faut sur PC, masqu√©e sur mobile */
#map {
    height: 50vh;
    width: 100%;
    border: 1px solid #ccc;
    box-shadow: 0 0 10px rgba(0,0,0,0.2);
    margin-bottom: 10px;
      display: none; 
}

/* Ajustement pour organiser la disposition avec le titre, le bouton, et la carte/liste */
.container {
    display: flex;
    flex-direction: row; /* Aligner la carte et la liste horizontalement */
    justify-content: space-between;
    align-items: flex-start;
    margin-top: 20px; /* Espacement entre le bouton et le contenu */
}

.map-container {
    display: flex;
    flex-direction: column; /* Aligner le bouton et la carte verticalement */
    flex: 2; /* La carte et son bouton occupent 2/3 de l'espace */
}

#map {
    height: 80vh; /* Ajuster la hauteur pour qu'elle soit plus grande */
    margin-top: 10px; /* Espacement entre le bouton et la carte */
}

#classement {
    flex: 1; /* La liste des joueurs occupe 1/3 de l'espace */
    max-height: 80vh; /* Limiter la hauteur pour √©viter le d√©bordement */
    overflow-y: auto; /* Ajouter un d√©filement si n√©cessaire */
}

.map-toggle {
    display: block; /* Toujours visible */
    background-color: #4CAF50;
    color: white;
    border: none;
    padding: 10px;
    margin: 10px auto; /* Centrer le bouton sous le titre */
    width: auto; /* Ajuster la largeur pour qu'elle s'adapte au contenu */
    border-radius: 4px;
    cursor: pointer;
    font-size: 1rem;
}

/* Ajout de styles pour les t√©l√©phones (responsive design) */
@media (max-width: 768px) {
    .container {
        flex-direction: column; /* Revenir √† une disposition verticale */
        align-items: center; /* Centrer les √©l√©ments */
    }

    .map-container {
        width: 100%; /* La carte prend toute la largeur */
    }

    #map {
        height: 50vh; /* R√©duire la hauteur de la carte */
        margin: 0; /* Supprimer les marges inutiles */
    }

    #classement {
        width: 100%; /* La liste des joueurs prend toute la largeur */
        max-height: none; /* Supprimer la limite de hauteur */
        overflow-y: visible; /* D√©sactiver le d√©filement */
    }

    .map-toggle {
        margin: 10px auto; /* Centrer le bouton */
    }

    /* Ajout de styles pour l'affichage mobile */
    .map-list-container {
        flex-direction: column; /* Passer √† une disposition verticale */
    }

    .map-container, .list-container {
        flex: none; /* R√©initialiser la flexibilit√© */
        width: 100%; /* Prendre toute la largeur */
        height: auto; /* Ajuster la hauteur automatiquement */
    }
}

    </style>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carte avec adresse de tournoi</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

</head>
<body>
    <div class="header">
        Master King of War France 2026
    </div>
    <div class="button-container">
        <button class="map-toggle" onclick="toggleMap()">Afficher/Masquer la carte</button>
    </div>
    <div class="map-list-container">
        <div class="map-container">
            <div id="map"></div>
        </div>
        <div id="classement" class="list-container">
            <table id="tableauJoueurs">
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Nom du joueur</th>
                        <th>R√©gion</th>
                        <th>Evenements</th>
                        <th>Points totaux</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
            </div>
          
        </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        function toggleMap() {
    const mapElement = document.getElementById('map');
    const button = document.querySelector('.map-toggle');
    if (mapElement.style.display === 'none' || mapElement.style.display === '') {
        mapElement.style.display = 'block';
        button.textContent = 'Masquer la carte';
        // Redimensionner la carte Leaflet apr√®s affichage
        setTimeout(() => map.invalidateSize(), 100);
    } else {
        mapElement.style.display = 'none';
        button.textContent = 'Afficher la carte';
    }
}
toggleMap()
        // Initialisation de la carte
        const map = L.map('map').setView([46.603354, 1.888334], 6);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);


        // Constante pour le nombre maximum de tournois √† prendre en compte
        const MaxTournamentCount = 4;

        // Fonction de calcul des points
        function calculPoint(deuxJours, classement, nombreTotal) {
            // Calcul de base : (nombreTotal/2 arrondi inf√©rieur) - classement - 1
            let points = Math.floor(nombreTotal / 2) - (classement - 1);
            
            // Bonus pour les tournois sur deux jours
            if (deuxJours) {
                if (classement === 1) {
                    points += 6;
                } else if (classement === 2) {
                    points += 3;
                } else if (classement === 3) {
                    points += 1;
                }
            }
            
            // Retourne 0 si le r√©sultat est n√©gatif
            return Math.max(0, points);
        }


        // Cr√©ation de la classe Classement
        class Classement {
            constructor(nomTournoi, urlTournoi, classement, points) {
                this.nomTournoi = nomTournoi;
                this.urlTournoi = urlTournoi;
                this.classement = classement;
                this.points = points;
            }
        }

        // Cr√©ation de la classe Joueur
        class Joueur {
            constructor(nom, region) {
                this.nom = nom;
                this.region = region;
                this.listeClassements = [];
                this.pointTotal = 0;
            }

            ajouterClassement(classement) {
                this.listeClassements.push(classement);
                // Trier les classements par points d√©croissants
                this.listeClassements.sort((a, b) => b.points - a.points);
                // Recalculer le total avec les MaxTournamentCount meilleurs r√©sultats
                this.pointTotal = this.listeClassements
                    .slice(0, MaxTournamentCount)
                    .reduce((sum, c) => sum + c.points, 0);
            }
        }


        // Champion de l'ann√©e derni√®re
        const ChampionLastYear = "Arthur aka \"AVL\"";

        // Liste globale des joueurs
        let allPlayers = new Map();

        // Charger d'abord les tournois
        const tournoiScript = document.createElement('script');
        tournoiScript.src = 'mockTournois.js';
        
        tournoiScript.onload = function() {
            if (typeof tournois !== 'undefined') {
                // Charger ensuite les joueurs
                const playersScript = document.createElement('script');
                playersScript.src = 'mockPlayer.js';
                document.body.appendChild(playersScript);

                playersScript.onload = function() {
                // Calculer les points pour chaque r√©sultat de chaque tournoi
                tournois.forEach(tournoi => {

                    const nombreTotal = tournoi.resultats.length;
                    tournoi.resultats.forEach(resultat => {
                        resultat.nombreDePoints = calculPoint(tournoi.deuxJours, resultat.classement, nombreTotal);
                    });
                    
                    // Calculer pointMax (points du premier)
                    tournoi.pointMax = tournoi.resultats.length > 0 ? tournoi.resultats[0].nombreDePoints : 0;
                    
                    // Calculer pointTotale (somme des points de tous les joueurs)
                    tournoi.pointTotale = tournoi.resultats.reduce((sum, resultat) => sum + resultat.nombreDePoints, 0);
                });

                // Grouper les tournois par coordonn√©es arrondies √† 3 d√©cimales
                const tournoiParCoords = tournois.reduce((acc, tournoi) => {
                    // Arrondir les coordonn√©es √† 3 d√©cimales
                    const latRound = Math.round(tournoi.lat * 1000) / 1000;
                    const lonRound = Math.round(tournoi.lon * 1000) / 1000;
                    const key = `${latRound},${lonRound}`;
                    
                    if (!acc[key]) {
                        acc[key] = {
                            lat: tournoi.lat, // Garder la premi√®re coordonn√©e exacte
                            lon: tournoi.lon,
                            tournois: []
                        };
                    }
                    acc[key].tournois.push(tournoi);
                    
                    // Si on vient d'ajouter un deuxi√®me tournoi ou plus √† ce groupe
                    if (acc[key].tournois.length > 1) {
                        console.log('Tournois regroup√©s aux coordonn√©es', latRound, lonRound, ':');
                        acc[key].tournois.forEach(t => console.log('-', t.nom));
                    }else{
                        console.log('Tournois tout seule', latRound, lonRound, ':');
                    }
                    return acc;
                }, {});

                // Cr√©er les markers pour chaque groupe de tournois
                Object.values(tournoiParCoords).forEach((group) => {
                    // Cr√©er le contenu du popup avec tous les tournois
                    const popupContent = group.tournois
                    .map(tournoi => {
                        const dateFin = tournoi.deuxJours ? ` au ${formatDateFR(new Date(new Date(tournoi.date).getTime() + 86400000).toISOString().split('T')[0])}` : '';
                        let popupContent = `
                            <b>${tournoi.nom}</b><br>
                            Date : ${formatDateFR(tournoi.date)}${dateFin}<br>
                            Points max : ${tournoi.pointMax}<br>
                            Points totaux : ${tournoi.pointTotale}<br>
                        `;
                        if (tournoi.url) {
                            popupContent += `<a href='${tournoi.url}' target='_blank'>Lien du tournoi</a>`;
                        }
                        return popupContent;
                    })
                    .join('<br><br>');
                    
                    L.marker([group.lat, group.lon]).addTo(map)
                        .bindPopup(popupContent);
                });

                // Cr√©ation des objets Joueur et de leurs classements
                if (typeof mockPlayer !== 'undefined') {
                    console.log('mockPlayer est d√©fini avec', mockPlayer.length, 'joueurs.');
                    // Initialiser les joueurs
                    mockPlayer.forEach(joueur => {
                        allPlayers.set(joueur.nom, new Joueur(joueur.nom, joueur.region));
                    });

                    console.log("test");

                    // Parcourir tous les tournois pour ajouter les classements
                    tournois.forEach(tournoi => {
                        tournoi.resultats.forEach(resultat => {
                            let joueur = allPlayers.get(resultat.nom);
                            if (joueur) {
                                const classement = new Classement(
                                    tournoi.nom,
                                    tournoi.url,
                                    resultat.classement,
                                    resultat.nombreDePoints
                                );
                                joueur.ajouterClassement(classement);
                            }
                        });
                    });

                    // Afficher le tableau des joueurs
                    const tbody = document.querySelector('#tableauJoueurs tbody');
                    const sortedPlayers = Array.from(allPlayers.values())
                        .sort((a, b) => {
                            // D'abord comparer les points totaux
                            const pointsDiff = b.pointTotal - a.pointTotal;
                            if (pointsDiff !== 0) return pointsDiff;
                            
                            // En cas d'√©galit√©, comparer le nombre de tounois jou√©s
                            return  a.listeClassements.length-b.listeClassements.length;
                        });

                    // Placer le ChampionLastYear en t√™te de la liste tri√©e
                    sortedPlayers.sort((a, b) => {
    if (a.nom === ChampionLastYear) return -1; // ChampionLastYear en premier
    if (b.nom === ChampionLastYear) return 1;

    // Comparer les points totaux
    const pointsDiff = b.pointTotal - a.pointTotal;
    if (pointsDiff !== 0) return pointsDiff;

    // En cas d'√©galit√©, comparer le nombre de tournois jou√©s
    return a.listeClassements.length - b.listeClassements.length;
});

                    // Filtrer les joueurs pour n'afficher que ceux ayant particip√© √† au moins un tournoi ou √©tant le ChampionLastYear
                    const filteredPlayers = sortedPlayers.filter(joueur => 
    joueur.listeClassements.length > 0 || joueur.nom === ChampionLastYear
);

                    // Garder une trace des joueurs qualifi√©s
                    const qualifiedPlayers = new Set();
                    
                    // Qualifier le champion de l'ann√©e derni√®re
                    const championIndex = filteredPlayers.findIndex(j => j.nom === ChampionLastYear);
                    if (championIndex !== -1) {
                        qualifiedPlayers.add(filteredPlayers[championIndex].nom);
                    }

                    // Qualifier les 14 premiers non d√©j√† qualifi√©s
                    let qualifiedCount = 0;
                    filteredPlayers.forEach((joueur, index) => {
                        if (qualifiedCount < 14 && !qualifiedPlayers.has(joueur.nom)) {
                            qualifiedPlayers.add(joueur.nom);
                            qualifiedCount++;
                        }
                    });

                    // Qualifier les premiers de chaque r√©gion non d√©j√† qualifi√©s
                    const regions = new Set(filteredPlayers.map(j => j.region));
                    regions.forEach(region => {
                        if (region) { // Ignorer les r√©gions non sp√©cifi√©es
                            const firstInRegion = filteredPlayers.find(j => 
                                j.region === region && !qualifiedPlayers.has(j.nom)
                            );
                            if (firstInRegion) {
                                qualifiedPlayers.add(firstInRegion.nom);
                            }
                        }
                    });

                    // Afficher les joueurs filtr√©s
                    filteredPlayers.forEach(joueur => {
    const tr = document.createElement('tr');
    if (qualifiedPlayers.has(joueur.nom)) {
        tr.classList.add('qualified');
    }

    // Cr√©er le contenu du tooltip
    const tooltipContent = joueur.listeClassements
        .map((c, index) => {
            const isBest = index < MaxTournamentCount;
            return `<div class="${isBest ? 'best-score' : ''} clickable" onclick="window.open('${c.urlTournoi}', '_blank')">
${isBest ? '‚ñ∫ ' : '  '}${c.nomTournoi}: ${c.classement}e (${c.points} pts)
</div>`;
        })
        .join('');

    const position = filteredPlayers.indexOf(joueur) + 1;
    tr.innerHTML = `
        <td>${position}</td>
        <td>${joueur.nom} ${joueur.nom === ChampionLastYear ? 'üëë' : ''}</td>
        <td>
            <span class="region-color
                ${joueur.region === 'Bretagne-Normandie' ? 'bretagne-normandie-color' :
                  joueur.region === 'Nord' ? 'nord-color' :
                  joueur.region === 'Loire' ? 'loire-color' :
                  joueur.region === 'Ardenne-Bourgogne' ? 'ardenne-bourgogne-color' :
                  joueur.region === 'Est' ? 'est-color' :
                  joueur.region === 'Aquitaine' ? 'aquitaine-color' :
                  joueur.region === 'Occitanie' ? 'occitanie-color' :
                  joueur.region === 'Auvergne' ? 'auvergne-color' :
                  joueur.region === 'Alpes' ? 'alpes-color' : ''}"></span>
            ${joueur.region || 'Non sp√©cifi√©e'}
        </td>
        <td>${joueur.listeClassements.length}</td>
        <td class="points-cell">
            ${joueur.pointTotal}
            <div class="tooltip">${tooltipContent}</div>
        </td>
    `;
    tbody.appendChild(tr);
});
                } else {
                    console.error('mockPlayer est ind√©fini.');
                }
                };
            }
        };
        document.body.appendChild(tournoiScript);
    </script>
    <script>
// Ajout d'une fonction pour formater les dates en fran√ßais
function formatDateFR(dateString) {
    const options = { day: 'numeric', month: 'long', year: 'numeric' };
    const date = new Date(dateString);
    return date.toLocaleDateString('fr-FR', options);
}



    </script>
    <!-- Ajout de la logique pour masquer la carte et √©tendre la liste -->
<script>
    document.addEventListener("DOMContentLoaded", function() {
        const toggleButton = document.querySelector(".map-toggle");
        const mapContainer = document.querySelector(".map-container");
        const listContainer = document.querySelector(".list-container");

        toggleButton.addEventListener("click", function() {
            if (mapContainer.style.display === "none") {
                mapContainer.style.display = "block";
                listContainer.style.flex = "1"; // Revenir √† 1/3 de largeur
                toggleButton.textContent = "Masquer la carte";
            } else {
                mapContainer.style.display = "none";
                listContainer.style.flex = "1 0 100%"; // Prendre toute la largeur
                toggleButton.textContent = "Afficher la carte";
            }
        });
    });
</script>
</body>
</html>
